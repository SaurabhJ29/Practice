#include <bits/stdc++.h>

using namespace std;

string ltrim(const string &);
string rtrim(const string &);

void extraLongFactorials(int n) {
    vector<int> result;
    result.push_back(1);

    for (int i = 2; i <= n; i++) {
        int carry = 0;
        for (int j = 0; j < result.size(); j++) {
            int product = result[j] * i + carry;
            result[j] = product % 10; // remainer when divided by 10
            carry = product / 10; // quotient when divided by 10
        }

        while (carry) {
            result.push_back(carry % 10); // pushing back to vector
            carry /= 10; // while loop conditon for pushing back the element.
            std::cout<<carry<<std::endl;
        }
    }

    for (int i = result.size() - 1; i >= 0; i--) {
        cout << result[i];
    }
}

int main()
{
    string n_temp;
    getline(cin, n_temp); //

    int n = stoi(ltrim(rtrim(n_temp))); //stoi: string to integar

    extraLongFactorials(n);

    return 0;
}

string ltrim(const string &str) {
    string s(str);

    s.erase(s.begin(), find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace))) );
    /* std::not1 is a helper function to create a function object that returns the complement 
    of the unary predicate function passed. 
    erase: Removes from the vector either a single element (position) or a range of elements 
    ([first, last)).
    This function is used to check if the argument contains any whitespace characters.*/
    
    return s;
}

string rtrim(const string &str) {
    string s(str);

    s.erase(find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(), s.end() );
    // r.begin() : reverse.begin()
    // r.end()  : reverse.end()
    
    return s;
}